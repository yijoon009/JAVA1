상속(inheritance)
	1. 기존에 선언된 클래스의 필드와 새롭게 선언할 클래스의
	   필드가 공통요소가 많이 있을 때에 사용한다.
	2. 여러 클래스를 만들 다 보니 공통된 필드가 많다면,
	    부모 클래스를 선언하여 공통요소를 묶어놓고,
	    각 클래스에 상속하여 사용한다.

상속 사용방법
	※ 상속은 단 한번만 사용할 수 있다.

	class A{
		A필드
	}
	
	class B extends A{
		A, B필드
	}

A : 부모 클래스, 상위 클래스, 슈퍼 클래스, 기반 클래스
B : 자식 클래스, 하위 클래스, 서브 클래스, 파생 클래스

super : 부모
	상속을 받게 되면 자식 객체로 부모 필드에 접근할 수 있다.
	하지만 자식을 객체화 할 때 자식 생성자만 호출하므로,
	자식 필드만 메모리에 할당된다고 생각할 수 있다.
	
	자식 생성자를 호출하게 되면 자동으로 부모 생성자를 호출하고,
	부모 필드가 할당 된 후 자식 필드가 할당된다.
	이 때 부모 생성자를 부르는 문법이 super()이며, 지워도 자동으로
	컴파일러가 작성 후 메모리에 할당하게 된다.

다형성(Polymorphism)
	1. 오버로딩(클래스 메모장 참고)

	2. 오버라이딩(재정의)
		부모 클래스를 상속받은 후 부모 필드의 메소드가
		마음에 들지 않거나 수정이 필요하다면,
		같은 이름의 메소드를 자식 클래스에서 선언하고
		재정의 할 수 있다. 재정의를 하게 되면 자식 객체는
		부모 필드의 메소드가 아닌 재정의된 메소드로 사용된다.

		메소드는 저장 공간이며, 부모 필드가 메모리에 먼저 할당된다.
		부모 필드에 있는 메소드가 메모리에 먼저 할당된 후 그 안에는
		부모 메소드에서 구현된 코드의 주소값이 있다.
		자식 필드 할당 시, 만약 자식 필드에서 선언한 메소드와 
		같은 이름의 메소드가 이미 할당되어 있다면
		기존에 할당된 메소드에 새롭게 정의한 코드의 주소값이
		덮어 씌워진다.

		※data를 메소드라 생각하고 선언부가 부모 필드라고 가정한다.
		int data = 10;		//부모
		data = 20;		//자식
		System.out.println(data)	//사용시 자식에서 정의한 값
	
		이것을 재정의(Overriding)이라고 한다.

[실습]
	강아지, 고양이, 돼지 클래스 선언.
	각 동물별로 울음소리를 다르게 출력
	※ 상속 사용
-------------------------------------------------------------------
배열(저장공간의 나열, 동적배열)
	무조건 같은 자료형만 담을 수 있다!

배열과 클래스의 차이점
	1. 배열은 무조건 같은 자료형, 클래스는 다른 자료형도 가능
	2. 배열은 값에 이름을 붙일 수 없지만, 클래스는 가능하다.

인덱스와 시작주소
	해당 주소에 접근할 때에는 []로 접근한다.
	인덱스 : 방 번호(0부터 시작한다)

메소드
	1. 이름() 단, 키워드()는 메소드X
	2. 저장공간 (작성한 코드의 주소값을 담고 있다)

메소드 선언
리턴타입 메소드명(자료형 매개변수명,....){
	실행할 문장;
	return 리턴값;
}

리턴
	생략이 가능하지만 생략시 반드시 리턴타입에 void를 적어주어야 한다.

	1. 메소드 내에서 모든 작업이 완료되었을 때 리턴을 적지 않는다.
	2. 메소드 내에서 작업이 모두 완료되지 않았을 때 리턴을 적는다.
	
메소드와 변수의 차이점
	1. 값과 주소값	
	2. 같은 이름으로 선언이 가능하다.
	3. void라는 타입이 있다.

목적
	1. 재사용(특정성 부여하지 않기!)
	2. 소스코드 간결화

다형성(Polymorphism)
	1. 오버로딩
		매개변수의 개수 또는 타입이 다르면 같은 이름으로 선언 가능
	2. 오버라이딩
		부모의 메소드를 무시하고 자식에서 재정의

클래스
	1. 주어이다.
	2. 타입이다.

객체화(인스턴스)
	클래스명 객체명 = new 생성자();

	1. 선언된 필드를 메모리에 할당하고 할당된 주소값을 가져오는 생성자
	2. 할당된 필드의 주소값을 기억할 객체
	3. 클래스는 타입이다.

생성자
	1. 클래스 선언 시 기본생성자 존재
	2. 직접 생성자 선언 시 선언된 생성자가 기본 생성자로 변경
	3. 초기화

목적
	반복되거나 공통된 요소(변수, 메소드)를 한 군데에 묶어서 관리하기 위함.
	필요할 때마다 객체화를 하거나 상속을 하여 생산.
	생산성을 높이기 위하여 사용한다.

상속
	여러 클래스의 필드들이 반복되는 선언을 한다면,
	하나의 클래스에 공통요소를 묶어놓고 상속해준다.

	1. 기존의 클래스 필드를 다른 클래스에게 전달
	2. 여러 클래스의 공통 요소를 묶어서 관리

super
	부모를 의미한다.

생성자
	자식 생성자를 호출하면 부모 생성자를 먼저 호출한다.

다중 상속(여러 부모를 상속하는 기법)

	JAVA에서는 다중상속을 지원하지 않는다.
	하지만 JDK8버전 이상부터는 사실상 다중상속을 지원하는 것으로 본다.


































